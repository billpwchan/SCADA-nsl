###############################################################################
#
# Namespace: 
# File name: scsgenutil.tcl
# Returns:
# Description: Proxy Generator utility procedures.
#
###############################################################################
#
# Author: Alain Bartolo
# Creation: 03/11/2000
# Modification:
#
###############################################################################

###############################################################################
#
# Procedure: generateHeader
# Returns:   the header string
# Description: generates a header. Args are:
#              fileName: Name of the generated file
#              sDesc   : Short description of the file
#              lDesc   : Long description of the file
#
###############################################################################
proc generateHeader {fileName sDesc lDesc {fileType idl}} {

    set toReturn ""

    if {[string compare $fileType "idl"] == 0} {
	append toReturn "\################################################################################\n"
	append toReturn "\#\n"
	append toReturn "\# File:        $fileName"
	append toReturn " ($sDesc"
	append toReturn ")\n"
	append toReturn "\# Description: $lDesc\n"
	append toReturn "\#\n"
	append toReturn "\# This file has been generated by the SOAP generator on "
	append toReturn [clock format [clock seconds] -format "%d %b %Y"]
	append toReturn ".\n"
	append toReturn "\# Do not delete it or edit it since changes will be \n"
	append toReturn "\# lost when next generation happens.\n"
	append toReturn "\#\n"
	append toReturn "\################################################################################\n"
    } else {
	append toReturn "// \################################################################################\n"
	append toReturn "// \#\n"
	append toReturn "// \# File:        $fileName"
	append toReturn " ($sDesc"
	append toReturn ")\n"
	append toReturn "// \# Description: $lDesc\n"
	append toReturn "// \#\n"
	append toReturn "// \# This file has been generated by the SOAP generator on "
	append toReturn [clock format [clock seconds] -format "%d %b %Y"]
	append toReturn ".\n"
	append toReturn "// \# Do not delete it or edit it since changes will be \n"
	append toReturn "// \# lost when next generation happens.\n"
	append toReturn "// \#\n"
	append toReturn "// \################################################################################\n"
    }
	
    return $toReturn
}

###############################################################################
#
# Procedure: addWhiteSpaces
# Returns: a new string containing numWhiteSpc spaces followed by toAdd
# Description: 
#
###############################################################################
proc addWhiteSpaces {toAdd numWhiteSpc} {
    
    set toReturn ""

    for {set numSpc 0} {$numSpc < $numWhiteSpc} { incr numSpc 1} {
	append toReturn " "
    }
    
    append toReturn $toAdd

    return $toReturn
}

###############################################################################
#
# Procedure: appendStr
# Returns: a new string containing a concatenation of all strings passed in the
#          argument list args
# Description: 
#
###############################################################################
proc appendStr {args} {

    set toReturn ""
    
    for {set i 0} {$i < [llength $args]} {incr i 1} {
	append toReturn [lindex $args $i]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: getNumberOfArgs
# Returns: the number of arguments for an IDL operation
# Description: gets rid of the first item in the list (return type) and counts 
#              the number of elements in the list
#
###############################################################################
proc getNumberOfArgs {operationName} {
    
    global IDLOperation
    
    # get rid of first ans second element (waymode & return value)
    set argList [lrange $IDLOperation($operationName) 2 end]

    return [llength $argList]
}

###############################################################################
#
# Procedure: getNumberOfOutArgs
# Returns: the number of "out"  arguments for an IDL operation
# Description: gets rid of the first item in the list (return type) and counts 
#              the number of elements in the list for which the mode (first 
#              element of the list) is "out" 
#
###############################################################################
proc getNumberOfOutArgs {operationName} {
    
    global IDLOperation
    
    # get rid of first and second element (waymode & return value)
    set argList [lrange $IDLOperation($operationName) 2 end]
    set toReturn 0

    for {set i 0} {$i < [llength $argList]} {incr i 1} {

	if {[string compare [lindex [lindex $argList $i] 0] "out"] == 0} {
	    incr toReturn 1
	}

    }

    return $toReturn
}


###############################################################################
#
# Procedure: getNumberOfInoutAndOutArgs
# Returns: the number of "out"  and "inout" arguments for an IDL operation
# Description: gets rid of the first item in the list (return type) and counts 
#              the number of elements in the list for which the mode (first 
#              element of the list) is "out" and "inout" 
#
###############################################################################
proc getNumberOfInoutAndOutArgs {operationName} {
    
    global IDLOperation
    
    # get rid of first and second element (waymode & return value)
    set argList [lrange $IDLOperation($operationName) 2 end]
    set toReturn 0

    for {set i 0} {$i < [llength $argList]} {incr i 1} {

	if {[string compare [lindex [lindex $argList $i] 0] "out"] == 0} {
	    incr toReturn 1
	}
	if {[string compare [lindex [lindex $argList $i] 0] "inout"] == 0} {
	    incr toReturn 1
	}

    }

    return $toReturn
}

###############################################################################
#
# Procedure: getNumberOfInAndInoutArgs
# Returns: the number of "in"  and "inout" arguments for an IDL operation
# Description: gets rid of the first item in the list (return type) and counts 
#              the number of elements in the list for which the mode (first 
#              element of the list) is "out" and "inout" 
#
###############################################################################
proc getNumberOfInAndInoutArgs {operationName} {
    
    global IDLOperation
    
    # get rid of first and second element (waymode & return value)
    set argList [lrange $IDLOperation($operationName) 2 end]
    set toReturn 0

    for {set i 0} {$i < [llength $argList]} {incr i 1} {

	if {[string compare [lindex [lindex $argList $i] 0] "in"] == 0} {
	    incr toReturn 1
	}
	if {[string compare [lindex [lindex $argList $i] 0] "inout"] == 0} {
	    incr toReturn 1
	}

    }

    return $toReturn
}


###############################################################################
#
# Procedure: outArgsOrReturnNonVoid
# Returns: Returns true if operation has at least one out arg or if return
#          value is not "void"
#
###############################################################################
proc outArgsOrReturnNonVoid {operationName} {
    
    global IDLOperation

    if {([getNumberOfInoutAndOutArgs $operationName] > 0 ) || ([lindex $IDLOperation($operationName) 1] != "void")} {
	return 1
    } else {
	return 0
    }
}

###############################################################################
#
# Procedure: getHelperForKind
# Arguments: - kind
#            - name
#            - cxxType
#            - direction ("from" or "to") - from for <<= operations
#                                           to   for >>= operations
#            - convertString - to indicate if (const char *) is to be added to 
#                              the string
# Returns: name with the right ANY helper if required according to the kind
# Description: Since the boolean, octet, char and wchar are not required to map 
#              to distinct C++ types, helpers are provided to map to and from 
#              the ANY type.
#
###############################################################################
proc getHelperForKind {kind name cxxType {direction from} {convertString 0}} {

    set toReturn ""
    if {[string compare $kind "char"] == 0} {
	append toReturn [appendStr "CORBA::Any::" $direction "_char(" $name ")"]
    } elseif { ([string compare $kind "boolean"] == 0) } {
	append toReturn [appendStr "CORBA::Any::" $direction "_boolean(" $name ")"]   	
    } elseif { ([string compare $kind "octet"] == 0) } {
	append toReturn [appendStr "CORBA::Any::" $direction "_octet(" $name ")"]
    } elseif { ([string compare $kind "string"] == 0) } {
	if {$convertString == 1} {
	    append toReturn "(const char*) "
	}
	append toReturn $name
    } elseif { ([string compare $kind "structvar"] == 0) } {
	if { ([string compare $direction "from"] == 0) } {
	    append toReturn [appendStr "(" [removeStr $cxxType "&"] ")"]
	}
	append toReturn $name
    } elseif { ([string compare $kind "array"] == 0) } {
	set typeToUse [removeStr [removeStr [removeStr $cxxType "_slice *"] "const"] "_out"]
	append toReturn [appendStr $typeToUse "_forany(" $typeToUse "_dup(" $name "), 1)"]
    } else {
	append toReturn $name
    }

    return $toReturn
}

###############################################################################
#
# Procedure: operationArgs
# Returns: a list of arguments for a given operation name.
# Description: goes through the list of arguments and creates a string containing
#              the arguments formated according to the following criteria:
#              - lang. "idl" to generate IDL code (mode, IDL type and name)
#                      "cxx" to generation C++ code (C++ type and name)
#              - mode. "all" to include all arguments
#                      "in"  to restrict to "in" arguments only
#                      "out" to restrict to "out" arguments only
#                      "inout" to restrict to "out" and "inout" arguments only
#              - insertSep. "1" to insert a separator before the first argument
#                           "0" to have no separator before the first argument
#              - appendRet. "1" to append a return (\n) after each argument
#                           "0" otherwise
#              - whiteSpaces. number of white spaces to add before each
#                             argument
#              - useSC. "0" use "," as the argument separator
#                       "1" use ";" as the argument separator
#              - transformArg. name of the procedure to call to transform each
#                              argument (null for none). Each transforArg 
#                              procedure must be declared as:
#                              proc XXX {cxxType name kind pos mode operationName
#                              where cxxType = the C++ type
#                                    name    = the argument name
#                                    kind    = the CORBA kind ("sequence", "ptr,
#                                              "string" or a basic CORBA kind 
#                                              ("short", "ulong", etc.)
#                                    pos     = the argument number (if a selection
#                                              has been applied (e.g. "out" only),
#                                              gives the position in the selection
#                                    mode    = "in" or "out"
#                                    operationName = the name of the IDL operation
#                                    
#
###############################################################################
proc operationArgs {operationName lang mode insertSep appendRet \
			{whiteSpaces 0} {useSC 0} \
			{transformArg null}} {
    global IDLOperation
    
    # get rid of first and second element (waymode & return value)
    set argList [lrange $IDLOperation($operationName) 2 end]

    # return empty string if no argument can be found
    if {[llength $argList] == 0} {
	return ""
    }
    
    # set first to 1 if we don't want to insert a comma, 0 otherwise.
    set first [expr !$insertSep]
    set retStr ""
    set counter 0

    for {set i 0} {$i < [llength $argList]} {incr i 1} {

	set currentOp         [lindex $argList $i]
	set currentIdlMode    [lindex $currentOp 0]
	set currentIdlType    [lindex $currentOp 1]
	set currentCxxType    [lindex $currentOp 2]
	set currentCxxOutType [lindex $currentOp 3]
	set currentName       [lindex $currentOp 4]
	set currentKind       [lindex $currentOp 5]
	
	if {([string compare $mode "all"] == 0) ||
	    (([string compare $mode "in"] == 0) && ([string compare $currentIdlMode "in"] == 0)) ||
	    (([string compare $mode "out"] == 0) && ([string compare $currentIdlMode "out"] == 0)) ||
      (([string compare $mode "inorinout"] == 0) &&   ( ([string compare $currentIdlMode "in"] == 0)
                                                       || ([string compare $currentIdlMode "inout"] == 0) )) ||
	    (([string compare $mode "inout"] == 0) &&   ( ([string compare $currentIdlMode "out"] == 0)
                                                       || ([string compare $currentIdlMode "inout"] == 0) ) ) } {

	    # Counter is mode dependant.
	    incr counter 1

	    # Append a comma after each argument
	    if {$first == 0} {

		if {$useSC == 1} {
		    append retStr "; "
		} else {
		    append retStr ", "
		}

		if {$appendRet == 1} {
		    append retStr "\n"
		}
	    }

	    # print either IDL or C++ type
	    if {[string compare $transformArg "null"] == 0} {
		if {[string compare $lang "idl"] == 0} {
		    set currentArg [appendStr $currentIdlMode " " $currentIdlType " " $currentName]
		} else {
		    set currentArg [appendStr $currentCxxType " " $currentName]
		}
	    } else {
		# call procedure to transform arguments in required format
		set currentArg [$transformArg $currentCxxType $currentName $currentKind \
				    $counter $currentIdlMode $operationName $currentCxxOutType \
				    $currentIdlType]
	    }

	    append retStr [addWhiteSpaces $currentArg $whiteSpaces]

	    set first 0
	}
    }

    return $retStr
}

###############################################################################
#
# Procedure: getTypeDef
# Returns: a new string
# Description: Get a C++ typedef for each out type of argument which is 
#              different from the in type.
#
###############################################################################
proc getTypeDef {operationName} {
    
    set toReturn ""

    set toReturn [replace [operationArgs $operationName cxx out 0 1 0 1 getTypeDefSub] ";;" ";"]

    return $toReturn
}

###############################################################################
#
# Procedure: getTypeDefSub
# Returns: a new string
# Description: creates the typedef string
#
###############################################################################
proc getTypeDefSub {cxxType name kind pos mode operationName cxxOutType idlType} {

    set toReturn ""

    if {[string compare $cxxType $cxxOutType] == 0} {
	set toReturn "// automatically inserted comment"
    } else {
	set toReturn "typedef $cxxType "
	append toReturn $cxxOutType
	append toReturn ";"
    }

    return $toReturn
}

###############################################################################
#
# Procedure: replace
# Returns: a new string
# Description: Replace all occurences of from with to in string toReplace 
#
###############################################################################
proc replace {toReplace from with {onlyOnce 0}} {

    set toReturn $toReplace
    set first [string first $from $toReturn]
    set fromLen [string length $from]

    while {$first != -1} {
	set toReturn [string replace $toReturn $first [expr $first - 1 + $fromLen] $with]
	
	if {$onlyOnce == 1} {
	    break
	} else {
	    set first [string first $from $toReturn]
	}
    }

    return $toReturn
}

###############################################################################
#
# Procedure: idlArgs
# Returns: a string containing a comma/new line separated list of all arguments
#          with the "mode Idltype name" format
# Description: 
#
###############################################################################
proc idlArgs {operationName {whiteSpaces 0}} {
    
    return [operationArgs $operationName idl all 1 1 $whiteSpaces]
}

proc idlOutToInArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn [appendStr "in " $idlType " " $name]

    return $toReturn
}

###############################################################################
#
# Procedure: idlOutToInArgs
# Returns: a string containing a comma/new line separated list of out arguments
#          with the "in Idltype name" format.
#          NOTE: "out" and "inout" args will appear as "in"
# Description: 
#
###############################################################################
# Same as idlArgs except that only "out" arguments are returned
# and "out" is converted to "in"   
proc idlOutToInArgs {operationName {whiteSpaces 0}} {
    
    # Only replace the first occurence of out by in since the variable name/type
    # might contain "out" like "listRoute"
    return [operationArgs $operationName idl inout 1 1 $whiteSpaces 0 idlOutToInArg]
}

proc idlInArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn [appendStr "in " $idlType " " $name]

    return $toReturn
}


proc idlInArgs {operationName {whiteSpaces 0}} {
    
    # get all in ans inout args inout set to in
    return [operationArgs $operationName idl inorinout 1 1 $whiteSpaces 0 idlInArg]
}

###############################################################################
#
# Procedure: cxxArgs
# Returns: a string containing a comma/new line separated list of all arguments
#          with the "cxxtype name" format. The first comma is added by default
#          unless "addFirstComma" is not "true"
# Description: 
#
###############################################################################
proc cxxArgs {operationName {whiteSpaces 0} {addFirstComma true}} {
    
    if {[string compare $addFirstComma "true"] == 0} {
	return [operationArgs $operationName cxx all 1 1 $whiteSpaces]
    } else {
	return [operationArgs $operationName cxx all 0 1 $whiteSpaces]
    }
}

###############################################################################
#
# Procedure: cxxArgsRef
# Returns: a string containing a comma/new line separated list of all arguments
#          with the "cxxtype name" format. The first comma is added by default
#          unless "addFirstComma" is not "true".
#          A "&" is added for out basic types.
# Description: See cxxArgRef
#
###############################################################################
proc cxxArgsRef {operationName {whiteSpaces 0} {addFirstComma true}} {
    
    if {[string compare $addFirstComma "true"] == 0} {
	return [operationArgs $operationName cxx all 1 1 $whiteSpaces 0 cxxArgRef]
    } else {
	return [operationArgs $operationName cxx all 0 1 $whiteSpaces 0 cxxArgRef]
    }
}

proc cxxInArgsRef {operationName {whiteSpaces 0} {addFirstComma true}} {
    
    if {[string compare $addFirstComma "true"] == 0} {
	return [operationArgs $operationName cxx inorinout 1 1 $whiteSpaces 0 cxxInArgRef]
    } else {
	return [operationArgs $operationName cxx inorinout 0 1 $whiteSpaces 0 cxxInArgRef]
    }
}

proc cxxInArgRef {cxxType name kind pos mode operationName cxxOutType idlType} {
    if {[string compare $mode "inout"] == 0} {
      if { ([string compare $kind "sequence"] == 0) || 
               ([string compare $kind "array"] == 0) || 
               ([string compare $kind "struct"] == 0) ||
               ([string compare $kind "structvar"] == 0)} {
      
        set toReturn [appendStr "const " $cxxType " " " $name"]
        
      } elseif { ([string compare $kind "string"] == 0) } {
        set toReturn [appendStr "const char * " $name]
      } else {
        set toReturn [appendStr [removeStr $cxxType "&"]  " " " $name"]
      }
    } else {
      set toReturn [appendStr $cxxType " " " $name"]
    }
    return $toReturn
}

###############################################################################
#
# Procedure: cxxArgRef
# Returns: a function argument format with a "&" for basic types.
# Description: 
#
###############################################################################
proc cxxArgRef {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    if {[string compare $kind "ptr"] == 0} {
	if {[string compare $mode "out"] == 0} {
	    set toReturn [appendStr $cxxOutType " " " $name"]
	} else {
	    set toReturn [appendStr $cxxType " " " $name"]
	}
    } else {
	    set toReturn [appendStr $cxxOutType " " $name]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: cxxArgReplyRef
# Returns: a function argument format with a "&" for basic types.
#           "_out" for array, sequence and structure                     
# Description:
#
###############################################################################
proc cxxArgReplyRef {cxxType name kind pos mode operationName cxxOutType idlType} {

    set toReturn ""

    if {[string compare $kind "ptr"] == 0} {
        if {[string compare $mode "out"] == 0} {
            set toReturn [appendStr $cxxOutType " " " $name"]
        } else {
            set toReturn [appendStr $cxxType " " " $name"]
        }
    } elseif { ([string compare $kind "sequence"] == 0) || 
               ([string compare $kind "array"] == 0) || 
               ([string compare $kind "struct"] == 0) ||
               ([string compare $kind "structvar"] == 0)} {
            set toReturn [appendStr $idlType "_out " $name] 
    } else {
            set toReturn [appendStr $cxxOutType " " $name]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: cxxArgsResult
# Returns: a string containing a comma/new line separated list of out and inout arguments
#          with the "cxxtype name" format. The first argument is not prefixed
#          with a comma.
# Description: see cxxArgOut
#
###############################################################################
proc cxxArgsResult {operationName {whiteSpaces 0} {addFirstComma true}} {

    if {[string compare $addFirstComma "true"] == 0} {
        set toReturn [operationArgs $operationName cxx inout 1 1 $whiteSpaces 0 cxxArgRef]
    } else {
	set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 0 cxxArgRef]
    }

    return $toReturn
}



###############################################################################
#
# Procedure: cxxArgsReply
# Returns: a string containing a comma/new line separated list of out arguments
#          with the "cxxtype name" format. The first argument is not prefixed
#          with a comma.
#          revertType reverts the types, an in type becomes an out type and
#          vice versa. Thus "char *& valueList" becomes
#          "const char * valueList" if revertType is set to "true"
# Description: see cxxArgOut
#
###############################################################################
proc cxxArgsReply {operationName whiteSpaces appendComma revertType} {

    if {[string compare $revertType "true"] == 0} {
        set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 0 cxxArgOut]
    } else {
        set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 0 cxxArgReplyRef]
    }

    if {([string length $toReturn] != 0) && ([string compare $appendComma "true"] == 0)} {
        append toReturn ","
    }
               
    return $toReturn
}


###############################################################################
#
# Procedure: cxxArgsOut
# Returns: a string containing a comma/new line separated list of out arguments
#          with the "cxxtype name" format. The first argument is not prefixed 
#          with a comma.
#          revertType reverts the types, an in type becomes an out type and
#          vice versa. Thus "char *& valueList" becomes 
#          "const char * valueList" if revertType is set to "true"
# Description: see cxxArgOut
#
###############################################################################
proc cxxArgsOut {operationName whiteSpaces appendComma revertType} {

    if {[string compare $revertType "true"] == 0} {
	set toReturn [operationArgs $operationName cxx out 0 1 $whiteSpaces 0 cxxArgOut]
    } else {
	set toReturn [operationArgs $operationName cxx out 0 1 $whiteSpaces 0 cxxArgRef]
    }

    if {([string length $toReturn] != 0) && ([string compare $appendComma "true"] == 0)} {
	append toReturn ","
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: cxxArgOut
# Returns: a string containing an argument initialisation.
# Description: 
#
###############################################################################
proc cxxArgOut {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    if {([string compare $kind "sequence"] == 0) || ([string compare -length 6 $kind "struct"] == 0)} {
	set toReturn [appendStr "const " [removeStr $cxxType "*"] " " $name]
    } else {
	if {[string compare $kind "string"] == 0} {
	    set toReturn [appendStr "const char * " $name]
	} elseif {[string compare $kind "array"] == 0} {
	 ##   set toReturn [appendStr "const " [removeStr $cxxType "_out"] " " $name]
            set toReturn [appendStr "const " $idlType " " $name]
	} else {
	    set toReturn [appendStr [removeStr $cxxType "&"] " " $name]
	}
    }

    return $toReturn
}

###############################################################################
#
# Procedure: initialiseOutArgs
# Returns: a semicolon/new line list of C++ initialisation for "out" arguments
# Description: see initialiseOutArg procedure
#
###############################################################################
proc initialiseOutArgs {operationName whiteSpaces} {

    set orbacusReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 1 initialiseOutArg]

    if {[string length $orbacusReturn] != 0} {
	append orbacusReturn ";"
    }
		  
    set toReturn "  // If you cannot compile this code because of an undefined '_forany' symbol, please recompile your IDLs using the '-A' option\n"
    append toReturn $orbacusReturn
    return $toReturn
}

###############################################################################
#
# Procedure: initialiseOutArg
# Returns: a string containing an argument initialisation.
# Description: "sequence" are dynamically allocated, others are set to 0.
#
###############################################################################
proc initialiseOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    if {([string compare $kind "sequence"] == 0) ||
        ([string compare $kind "union"] == 0) } {
	set toReturn [appendStr "const " $idlType  " " * " " $name " = 0"]
    } elseif {[string compare $kind "string"] == 0} {
	set toReturn [appendStr "const char * " $name " = 0"]
    } elseif {[string compare $kind "structvar"] == 0} {
	set toReturn [appendStr "const " [removeStr [removeStr $cxxType "&"] "*"] " " * $name]
    } elseif {[string compare -length 6 $kind "struct"] == 0} {
	set toReturn [appendStr "const " [removeStr $cxxType "&"] " " * $name]
    } elseif {[string compare $kind "array"] == 0} {
	set toReturn [appendStr [removeStr [removeStr [removeStr $cxxType "_slice *"] "&"] "_out"] "_forany " $name]
    } else {
	set toReturn [appendStr [removeStr $cxxType "&"] " " $name " = 0"]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: uniqueOutArgs
# Returns: a semicolon/new line list of variable names for "out" arguments
#          names are created with the format "_operationName_argumentName".
# Description: see uniqueOutArg procedure
#
###############################################################################
proc uniqueOutArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 1 uniqueOutArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: uniqueOutArg
# Returns: a string containing a unique variable name
# Description: 
#
###############################################################################
proc uniqueOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {

    set toReturn ""
    
    # Variable length structs ("structvar") and Sequence
    # are defined as pointers
    # -------------------------------------------------------------
    if {([string compare $kind "sequence"] == 0) || ([string compare $kind "structvar"] == 0)} {
          set toReturn [appendStr "$idlType *" " _" $operationName "_" $name]

    # Fixed length structs ("struct") are defined as fixed length.
    # ---------------------------------------------------------
    } elseif { [string compare $kind "struct"] == 0} {
          set toReturn [appendStr "$idlType " " _" $operationName "_" $name]

    # Fixed and Variable Length "array" return a fixed count array (element can be varible length 
    # -------------------------------------------------------------------------------------------
    } elseif {[string compare $kind "array"] == 0} {
          set toReturn [appendStr "$idlType " " _" $operationName "_" $name]

    } else {
    set toReturn [appendStr [removeStr $cxxType "&"] " _" $operationName "_" $name]
    }
    
    return $toReturn
}



###############################################################################
#
# Procedure: initTmpOutArgs
# Returns: a semicolon/new line list of variable names for tmp "out" arguments
#          names are created with the format "tmp_argumentName".
# Description: see uniqueOutArg procedure
#
###############################################################################
proc initTmpOutArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx out 0 1 $whiteSpaces 1 initTmpOutArg]

    if {[string length $toReturn] != 0} {
	    append toReturn ";"
    }
		  
    return $toReturn
}
proc declareOutArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx out 0 1 $whiteSpaces 1 declareOutArg]

    if {[string length $toReturn] != 0} {
	    append toReturn ";"
    }
		  
    return $toReturn
}
###############################################################################
#
# Procedure: initTmpOutArg
# Returns: a string containing declaration of a tmp variable name
# Description: 
#
###############################################################################


###############################################################################
#
# Procedure: uniqueOutArg
# Returns: a string containing declaration of a tmp variable name
# Description: 
#
###############################################################################
proc initTmpOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    if {[string compare $kind "string"] == 0} {
        return [appendStr "char *tmp_" $name " = NULL"]

    } elseif {[string compare $kind "short"] == 0} {
        return [appendStr "CORBA::Short tmp_" $name " = 0"]    

    } elseif {[string compare $kind "long"] == 0} {
        return [appendStr "CORBA::Long tmp_" $name " = 0"]    

    } elseif {[string compare $kind "unsigned short"] == 0} {
        return [appendStr "CORBA::UShort tmp_" $name " = 0"]    

    } elseif {[string compare $kind "unsigned long"] == 0} {
        return [appendStr "CORBA::ULong tmp_" $name " = 0"]    

    } elseif {[string compare $kind "float"] == 0} {
        return [appendStr "CORBA::Float tmp_" $name " = 0"]    

    } elseif {[string compare $kind "double"] == 0} {
        return [appendStr "CORBA::Double tmp_" $name " = 0"]    

    } elseif {[string compare $kind "boolean"] == 0} {
        return [appendStr "CORBA::Boolean tmp_" $name " = 0"]    

    } elseif {[string compare $kind "char"] == 0} {
        return [appendStr "CORBA::Char tmp_" $name " = 0"]    

    } elseif {[string compare $kind "octet"] == 0} {
        return [appendStr "CORBA::Octet tmp_" $name " = 0"]    

    } elseif {[string compare $kind "long long"] == 0} {
        return [appendStr "CORBA::LongLong tmp_" $name " = 0"]    

    } elseif {[string compare $kind "unsigned long long"] == 0} {
        return [appendStr "CORBA::ULongLong tmp_" $name " = 0"]    

    } elseif {[string compare $kind "long double"] == 0} {
        return [appendStr "CORBA::LongDouble tmp_" $name " = 0"]    

    } elseif {[string compare $kind "wchar"] == 0} {
        return [appendStr "CORBA::WChar tmp_" $name " = 0"]    

    } elseif {[string compare $kind "struct"] == 0} {
	return [appendStr [string range $cxxOutType 0 [expr [string length $cxxOutType] - 5] ] " tmp_" $name]
    } else {
        return [appendStr "$idlType *tmp_" $name " = NULL"]
    }
}
    
proc declareOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    if {[string compare $kind "string"] == 0} {
        return [appendStr "char * " $name " = NULL"]

    } elseif {[string compare $kind "short"] == 0} {
        return [appendStr "CORBA::Short " $name " = 0"]    

    } elseif {[string compare $kind "long"] == 0} {
        return [appendStr "CORBA::Long " $name " = 0"]    

    } elseif {[string compare $kind "unsigned short"] == 0} {
        return [appendStr "CORBA::UShort " $name " = 0"]    

    } elseif {[string compare $kind "unsigned long"] == 0} {
        return [appendStr "CORBA::ULong " $name " = 0"]    

    } elseif {[string compare $kind "float"] == 0} {
        return [appendStr "CORBA::Float " $name " = 0"]    

    } elseif {[string compare $kind "double"] == 0} {
        return [appendStr "CORBA::Double " $name " = 0"]    

    } elseif {[string compare $kind "boolean"] == 0} {
        return [appendStr "CORBA::Boolean " $name " = 0"]    

    } elseif {[string compare $kind "char"] == 0} {
        return [appendStr "CORBA::Char " $name " = 0"]    

    } elseif {[string compare $kind "octet"] == 0} {
        return [appendStr "CORBA::Octet " $name " = 0"]    

    } elseif {[string compare $kind "long long"] == 0} {
        return [appendStr "CORBA::LongLong " $name " = 0"]    

    } elseif {[string compare $kind "unsigned long long"] == 0} {
        return [appendStr "CORBA::ULongLong " $name " = 0"]    

    } elseif {[string compare $kind "long double"] == 0} {
        return [appendStr "CORBA::LongDouble " $name " = 0"]    

    } elseif {[string compare $kind "wchar"] == 0} {
        return [appendStr "CORBA::WChar " $name " = 0"]    

    } elseif {[string compare $kind "struct"] == 0} {
      return [appendStr [string range $cxxOutType 0 [expr [string length $cxxOutType] - 5] ] " " $name]
    } elseif {[string compare $kind "sequence"] == 0} {
        return [appendStr "$idlType " $name]
    } else {
        return [appendStr "$idlType " $name]
    }
}

###############################################################################
#
# Procedure: cxxArgsTmpForOut
# Returns: a comma/new line list of variable names with tmp_$name for out args
# Description: see cxxArgOutNoType procedure
#
###############################################################################
proc cxxArgsTmpForOut {operationName whiteSpaces} {

    return [operationArgs $operationName cxx all 0 1 $whiteSpaces 0 cxxArgTmpForOut]
}


###############################################################################
#
# Procedure: cxxArgTmpForOut
# Returns: a string containing a variable name or tmp_$name if it is an out arg
# Description: 
#
###############################################################################
proc cxxArgTmpForOut {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    if {[string compare $mode "out"] == 0} {
        return [appendStr "tmp_" $name]
    } else {
        return $name
    }
}




###############################################################################
#
# Procedure: cxxArgsOutNoType
# Returns: a comma/new line list of variable names for "out" and "inout" arguments
# Description: see cxxArgOutNoType procedure
#
###############################################################################
proc cxxArgsOutNoType {operationName whiteSpaces} {

    return [operationArgs $operationName cxx inout 0 1 $whiteSpaces 0 cxxArgOutNoType]
}

###############################################################################
#
# Procedure: cxxArgOutNoType
# Returns: a string containing a variable name
# Description: 
#
###############################################################################
proc cxxArgOutNoType {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    return $name
}

###############################################################################
#
# Procedure: cxxArgsNoType
# Returns: a comma/new line list of variable names for all arguments
# Description: see cxxArgNoType procedure
#
###############################################################################
proc cxxArgsNoType {operationName whiteSpaces} {

    return [operationArgs $operationName cxx all 0 1 $whiteSpaces 0 cxxArgNoType]
}

proc cxxInArgsNoType {operationName whiteSpaces} {

    return [operationArgs $operationName cxx inorinout 0 1 $whiteSpaces 0 cxxArgNoType]
}

###############################################################################
#
# Procedure: cxxArgNoType
# Returns: a string containing a variable name
# Description: 
#
###############################################################################
proc cxxArgNoType {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    return $name
}

###############################################################################
#
# Procedure: uniqueOutArgsInit
# Returns: a string containing a ctor initialisation type comma/new line separated 
#          list of all arguments defined in uniqueOutArgs
#          with the format _operationName_varName(0)
# Description: see proc uniqueOutArgInit
#
###############################################################################
proc uniqueOutArgsInit {operationName whiteSpaces} {

    return [operationArgs $operationName cxx out 1 1 $whiteSpaces 0 uniqueOutArgInit]
}

###############################################################################
#
# Procedure: uniqueOutArgInit
# Returns: a string containing a ctor like initialisation
# Description: 
#
###############################################################################
proc uniqueOutArgInit {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    return [appendStr "_" $operationName "_" $name "(NULL)"]
}

###############################################################################
#
# Procedure: uniqueOutArgsSet
# Returns: a string containing a semi_colon/new line separated list of initialisations
#          for the arguments defined in uniqueOutArgs
#          with the format _operationName_varName = varName;
#                    or _operationName_varName = _dup(varName);
# Description: see proc uniqueOutArgSet
#
###############################################################################
proc uniqueOutArgsSet {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 1 uniqueOutArgSet]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: uniqueOutArgSet
# Returns: a per argument initialisation string
# Description: 
#
###############################################################################
proc uniqueOutArgSet {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    ## Sequence allocation
    # ---------------------
    if {[string compare $kind "sequence"] == 0} {

	# Get rid of extra "&" and "*"
	set typeToReturn $cxxType
	set pos [string first " " $typeToReturn]

	if {$pos != -1} {
	    set typeToReturn [string range $typeToReturn 0 [expr $pos - 1]]
	}

	set toReturn [appendStr "_" $operationName "_" $name " = new " $typeToReturn "(" $name ")"]

    ## Variable Struct allocation
    # ----------------------------
    } elseif {[string compare $kind "structvar"] == 0} {
	set toReturn [appendStr "_" $operationName "_" $name " = new " [removeStr [removeStr $cxxType "&"] "*"] "(" $name ")"]

    ## String Allocation 
    #  ------------------
    } elseif {[string compare $kind "string"] == 0} {
	set toReturn [appendStr "_" $operationName "_" $name " = CORBA::string_dup(" $name ")"]

    # Array Fixed or Variable length duplication
    # -------------------------------------------
    } elseif {[string compare $kind "array"] == 0} {
	set toReturn [appendStr $idlType "_copy(" "_" $operationName "_" $name ", "  $name ")"]

    } else {
	set toReturn [appendStr "_" $operationName "_" $name " = " $name]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: uniqueOutArgsPutBack
# Returns: a string containing a semi_colon/new line separated list of "get"
#          for the arguments defined in uniqueOutArgs
#          with the format varName = _operationName_varName;
# Description: see proc uniqueOutArgPutBack
#
###############################################################################
proc uniqueOutArgsPutBack {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 1 uniqueOutArgPutBack]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: uniqueOutArgPutBack
# Returns: a per argument putback string
# Description: 
#
###############################################################################
proc uniqueOutArgPutBack {cxxType name kind pos mode operationName cxxOutType idlType} {

    set toReturn ""

    # Variable length structs ("structvar") and sequence are defined as pointers
    # Fixed length structs ("struct") are defined as variables.
    # Inout: In case of CORBA::String  free the string before Result
    # --------------------------------------------------------------
    if {([string compare $mode "inout"] == 0) && ([string compare $kind "string"] == 0)} {
        set toReturn [appendStr "string_free(" $name "); " $name  " = _" $operationName "_" $name]
    } elseif {([string compare $mode "inout"] == 0) && (([string compare $kind "structvar"] == 0) || ([string compare $kind "sequence"] == 0)) } {
        set toReturn [appendStr $name " = (*_" $operationName "_" $name ")"]
    } elseif {[string compare $kind "array"] == 0} {
	set toReturn [appendStr $idlType "_copy(" $name ", _" $operationName "_" $name " )"]
    } else {
	set toReturn [appendStr $name  " = _" $operationName "_" $name]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: decodeArgs
# Returns: a string containing a list of decode statements for "out" arguments
#          arguments are decoded according to their kind:
#          for a sequence:    "(*argName).decodeOp(*fromRequest)"
#                string:      "fromRequest->decodeStringOp(argName)
#                basic types: "(*fromRequest) >> argName"
# Description: see proc decodeArg
#
###############################################################################
proc decodeArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 1 decodeArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: decodeArg
# Returns: a per argument decode statement
# Description: 
#
###############################################################################
proc decodeArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    # find number of out arg in operation
    
    global IDLOperation
    
    # get rid of first and second element (waymode & return value)
    set argList [lrange $IDLOperation($operationName) 2 end]
    
    set num 0
    for {set i 0} {$i < [llength $argList]} {incr i 1} {
	    set currentOp         [lindex $argList $i]
	    set currentName       [lindex $currentOp 4]
        if {[string compare $currentName $name] == 0} {
            set num $i
        }
    }

    set toReturn [appendStr "*(fromRequest->arguments()->item(" $num \
		      ")->value()) >>= "]
    if {[string compare $kind "array"] == 0} {
	append toReturn $name
    } else { 
	append toReturn [getHelperForKind $kind $name $cxxType to ]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: addToArgListOutArgs
# Returns: a string containing a list of addition to an arglist statements for 
#          "out" arguments.
# Description: see proc addToArgListOutArg
#
###############################################################################
proc addToArgListOutArgs {operationName whiteSpaces} {
    
    set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 1 addToArgListOutArg]
    
    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }

    return $toReturn
}

###############################################################################
#
# Procedure: addToArgListOutArg
# Returns: a per argument "arglist add" statement
# Description: 
#
###############################################################################
proc addToArgListOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn [appendStr "*(toRequest->arguments()->item(" \
		      [expr $pos + 1] ")->value()) <<= "]
    
    if {([string compare $kind "ptr"] == 0) ||
	([string compare $kind "sequence"] == 0) ||
	([string compare -length 6 $kind "struct"] == 0) } {
	append toReturn "*"
    } elseif {[string compare $kind "array"] == 0} {
	# nothing to do
    } else {
	set name [getHelperForKind $kind $name $cxxType]
    }

    append toReturn $name

    return $toReturn
}

###############################################################################
#
# Procedure: deleteAddedArgs
# Returns: a string containing a list of "memory deallocation for sequences" statements 
# Description: see proc deleteAddedArg
#
###############################################################################
proc deleteAddedArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx out 0 1 $whiteSpaces 1 deleteAddedArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: deleteAddedArg
# Returns: a per argument "memory deallocation for sequences" statement
# Description: 
#
###############################################################################
proc deleteAddedArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    if {([string compare $kind "sequence"] == 0) || ([string compare $kind "string"] == 0)} {
	set toReturn [appendStr "delete " $name]
    } else {
	# not very nice but it will generate a comment line with a ";"
	# this helps keeping the structure intact
	set toReturn "// Automatically generated comment - please ignore"
    }

    return $toReturn
}

###############################################################################
#
# Procedure: allocateOrInitOutReplyArgs
# Returns: a string containing a list of initialisation/allocation statements
#          for "out" arguments.
#          Arguments are initialised according to their kind:
#          for a sequence:    "argName = new argType"
#                string:      "argName = new char"
#                basic types: "argName = 0"
# Description: see proc allocateOrInitOutArg
#
###############################################################################
proc allocateOrInitOutReplyArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 1 allocateOrInitOutArg]

    if {[string length $toReturn] != 0} {
        append toReturn ";"
    }
               
    return $toReturn
}


###############################################################################
#
# Procedure: allocateOrInitOutArgs
# Returns: a string containing a list of initialisation/allocation statements 
#          for "out" arguments.
#          Arguments are initialised according to their kind:
#          for a sequence:    "argName = new argType"
#                string:      "argName = new char"
#                basic types: "argName = 0"
# Description: see proc allocateOrInitOutArg
#
###############################################################################
proc allocateOrInitOutArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx out 0 1 $whiteSpaces 1 allocateOrInitOutArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: allocateOrInitOutArg
# Returns: a per argument initialisation/allocation statement
# Description: 
#
###############################################################################
proc allocateOrInitOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    if {([string compare $mode "inout"] ==0) && ([string compare $kind "sequence"] == 0)} {
        set toReturn "// Automatically generated comment (Inout Sequence) - please ignore"
    } elseif {[string compare $kind "sequence"] == 0} {
	set toReturn [appendStr $name " = new " [removeStr [removeStr $cxxType "&"] "*"]]
    } elseif {[string compare $kind "string"] == 0} {
	set toReturn [appendStr $name " = CORBA::string_dup(\"\")"]
    } elseif {([string compare $mode "inout"] ==0) && ([string compare $kind "structvar"] == 0)} {
         set toReturn "// Automatically generated comment (Inout Structvar) - please ignore"
    } elseif {[string compare $kind "structvar"] == 0} {
	set toReturn [appendStr $name " = new " [removeStr [removeStr $cxxType "&"] "*"]]
    } elseif {[string compare $kind "struct"] == 0} {
	set toReturn "// Automatically generated comment (struct type) - please ignore"
    } elseif {[string compare $kind "array"] == 0} {
	set toReturn "// Automatically generated comment (array type) - please ignore"
    } else {
	set toReturn [appendStr $name " = 0"]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: duplicateArgs
# Returns: a string containing duplicate statements 
#          for "out" arguments.
#          Arguments are duplicated according to their kind:
#          for a ptr:    "cxxType::_duplicate(argName)
#                string &
#                basic types: no duplication
# Description: see proc duplicateArg
#
###############################################################################
proc duplicateArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx all 0 1 $whiteSpaces 1 duplicateArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: duplicateArg
# Returns: a per argument duplication statement
# Description: 
#
###############################################################################
proc duplicateArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    if {[string compare $kind "ptr"] == 0} {
	set toReturn "// Automatically generated comment for ptr type - please ignore"
    } else {
	set toReturn "// Automatically generated comment - please ignore"
    }

    return $toReturn
}

###############################################################################
#
# Procedure: encodeArgs
# Returns: a string containing encode statements 
#          for "in" arguments.
#          Arguments are encoded according to their kind:
#          for a ptr:    "oRequest->encodeForwardRef(cxxType _getBase, $cxxType _ptr$argName)"
#                string: "oRequest->encodeStringOp(argName)"
#                basic types: "$name "argName.encodeOp(*oRequest)
# Description: see proc encodeArg
#
###############################################################################
proc encodeArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx in 0 1 $whiteSpaces 1 encodeArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: encodeArg
# Returns: a per argument encode statement
# Description: 
#
###############################################################################
proc encodeArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    if {[string compare $kind "ptr"] == 0} {
	set toReturn [appendStr "oRequest->encodeForwardRef(" \
			  $cxxType "_getBase,\n                                (" $cxxType "_ptr) " $name ")"]
    } elseif {[string compare $kind "string"] == 0} {
	set toReturn [appendStr "oRequest->encodeStringOp(" $name ")"]
    } elseif {[string compare $kind "sequence"] == 0} {
	set toReturn [appendStr $name ".encodeOp(*oRequest);"]
    } else {
	set toReturn [appendStr "*oRequest << " $name]
    }

    return $toReturn
}


#
# Procedure: deleteOutArgs
# Returns: a string containing delete statements 
#          for "out" arguments.
#          Arguments are deleted according to their kind:
#          for a ptr:    nothing
#                string: "delete argName"
#                basic types: nothing
# Description: see proc deleteOutArg
#
###############################################################################
proc deleteOutArgs {operationName whiteSpaces} {

    set toReturn [operationArgs $operationName cxx out 0 1 $whiteSpaces 1 deleteOutArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return $toReturn
}

###############################################################################
#
# Procedure: deleteOutArg
# Returns: a per argument delete statement
# Description: 
#
###############################################################################
proc deleteOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    set toReturn ""

    if {([string compare $kind "string"] == 0) || ([string compare $kind "sequence"] == 0)} {
	set toReturn [appendStr "delete " $name]
    } else {
	set toReturn "// Automatically generated comment - please ignore"
    }

    return $toReturn
}

###############################################################################
#
# Procedure: addToArgListAllTmpForOutArgs
# Returns: a string containing arglist addition statements 
#          for "all" arguments.
#          Arguments are added according to their mode:
#          for a in:     "ARG_IN)->value()) <<= argName"
#              inout:     "ARG_INOUT)->value()) <<= argName"
#                out:    "ARG_OUT)->value()) <<= argName"
# Description: see proc addToArgListAllArg
#
###############################################################################
proc addToArgListAllTmpForOutArgs {operationName whiteSpaces varName} {

    set toReturn [addWhiteSpaces "// If you cannot compile this code because of an undefined '_forany' symbol, please recompile your IDLs using the '-A' option\n" $whiteSpaces]
    
    append toReturn [operationArgs $operationName cxx all 0 1 $whiteSpaces 1 addToArgListAllTmpForOutArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return [replace $toReturn DUMMY_NAMED_VAR $varName]
}

###############################################################################
#
# Procedure: addToArgListAllArg
# Returns: a per argument arglist addition statement
# Description: 
#
###############################################################################
proc addToArgListAllTmpForOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {

    
    # DUMMY_NAMED_VAR is later replaced by the actual variable name
    set toReturn "*(DUMMY_NAMED_VAR->add(CORBA::"

    if {[string compare $mode "out"] == 0} {
	append toReturn "ARG_OUT)->value()) <<= "
    } elseif {[string compare $mode "inout"] == 0} {
        append toReturn "ARG_INOUT)->value()) <<= "
    } else {
	append toReturn "ARG_IN)->value()) <<= "
    }

    if {[string compare $mode "out"] == 0} {
    	append toReturn [getHelperForKind $kind [appendStr "tmp_" $name ] $cxxType from]

    } else {
    	append toReturn [getHelperForKind $kind $name $cxxType from 1]

    }

    return $toReturn
}

###############################################################################
#
# Procedure: addToArgListAllArgs
# Returns: a string containing arglist addition statements 
#          for "all" arguments.
#          Arguments are added according to their mode:
#          for a in:     "ARG_IN)->value()) <<= argName"
#              inout:     "ARG_INOUT)->value()) <<= argName"
#                out:    "ARG_OUT)->value()) <<= argName"
#          for sequences, a "*" is prefixed to argName
# Description: see proc addToArgListAllArg
#
###############################################################################
proc addToArgListAllArgs {operationName whiteSpaces varName} {

    set toReturn [addWhiteSpaces "// If you cannot compile this code because of an undefined '_forany' symbol, please recompile your IDLs using the '-A' option\n" $whiteSpaces]
    
    append toReturn [operationArgs $operationName cxx all 0 1 $whiteSpaces 1 addToArgListAllArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return [replace $toReturn DUMMY_NAMED_VAR $varName]
}

proc addToArgListInArgs {operationName whiteSpaces varName} {

    set toReturn [addWhiteSpaces "// If you cannot compile this code because of an undefined '_forany' symbol, please recompile your IDLs using the '-A' option\n" $whiteSpaces]
    
    append toReturn [operationArgs $operationName cxx inorinout 0 1 $whiteSpaces 1 addToArgListInArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return [replace $toReturn DUMMY_NAMED_VAR $varName]
}

###############################################################################
#
# Procedure: addToArgListAllArg
# Returns: a per argument arglist addition statement
# Description: 
#
###############################################################################
proc addToArgListAllArg {cxxType name kind pos mode operationName cxxOutType idlType} {

    
    # DUMMY_NAMED_VAR is later replaced by the actual variable name
    set toReturn "*(DUMMY_NAMED_VAR->add(CORBA::"

    if {[string compare $mode "out"] == 0} {
	append toReturn "ARG_OUT)->value()) <<= "
    } elseif {[string compare $mode "inout"] == 0} {
        append toReturn "ARG_INOUT)->value()) <<= "
    } else {
	append toReturn "ARG_IN)->value()) <<= "
    }

    if {([string compare $mode "out"] == 0) && 
       ( ([string compare $kind "sequence"] == 0) || ([string compare $kind "structvar"] == 0) )} {
	append toReturn [appendStr $name ]
    } else {
    
    	append toReturn [getHelperForKind $kind $name $cxxType from 1]
    }

    return $toReturn
}

proc addToArgListInArg {cxxType name kind pos mode operationName cxxOutType idlType} {

    
    # DUMMY_NAMED_VAR is later replaced by the actual variable name
    set toReturn "*(DUMMY_NAMED_VAR->add(CORBA::"

    if {[string compare $mode "out"] == 0} {
	append toReturn "ARG_OUT)->value()) <<= "
    } elseif {[string compare $mode "inout"] == 0} {
        append toReturn "ARG_IN)->value()) <<= "
    } else {
	append toReturn "ARG_IN)->value()) <<= "
    }

    if {([string compare $mode "out"] == 0) && 
       ( ([string compare $kind "sequence"] == 0) || ([string compare $kind "structvar"] == 0) )} {
	append toReturn [appendStr "*" $name ]
    } else {
    
    	append toReturn [getHelperForKind $kind $name $cxxType from 1]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: addToArgListAnswerOutArgs
# Returns: a string containing arglist answer addition statements 
#          for "out" arguments.
#          Arguments are added with the format:
#             "*(argListAnswer->add(CORBA::ARG_IN)->value()) <<= argName"
#             for sequence args, a "*" is prefixed to argName
# Description: see proc addToArgListAnswerOutArgs
#
###############################################################################
proc addToArgListAnswerOutArgs {operationName whiteSpaces varName} {

    set toReturn [operationArgs $operationName cxx inout 0 1 $whiteSpaces 1 addToArgListAnswerOutArg]

    if {[string length $toReturn] != 0} {
	append toReturn ";"
    }
		  
    return [replace $toReturn DUMMY_NAMED_VAR $varName]
}

###############################################################################
#
# Procedure: addToArgListAnswerOutArg
# Returns: a per argument arglist answer addition statement
# Description: 
#
###############################################################################
proc addToArgListAnswerOutArg {cxxType name kind pos mode operationName cxxOutType idlType} {
    
    # DUMMY_NAMED_VAR is later replaced by the actual variable name
    set toReturn "*(DUMMY_NAMED_VAR->add(CORBA::ARG_IN)->value()) <<= "

    if {([string compare $kind "sequence"] == 0) || ([string compare $kind "structvar"] == 0)} {
        if {[string compare $mode "inout"] == 0} {
           append toReturn [appendStr "(" $name ")"]
        } else {
	   append toReturn [appendStr "(" $name ")"]
        }
    } elseif {[string compare $kind "array"] == 0} {
	set typeToUse [removeStr [removeStr [removeStr [removeStr $cxxType "_slice"] "*"] "const"] "_out"]
	append toReturn [appendStr $idlType "_forany(" $idlType "_dup(" $name "), 1)"]	
    } else {
	append toReturn [getHelperForKind $kind $name $cxxType]
    }

    return $toReturn
}

###############################################################################
#
# Procedure: staticFunctionOrAnswer
# Returns: returns "answer" if no "out" or "inout" args can be found,
#          interfaceName_operationNameAnswer otherwise
# Description: 
#
###############################################################################
proc staticFunctionOrAnswer {interfaceName operationName} {

    global IDLOperation

    if {[getNumberOfInoutAndOutArgs $operationName] == 0} {
	# oneway operations or operations without 'out' args and returning void don't need an
	# answer at all
	if {([string compare [lindex $IDLOperation($operationName) 0] "oneway"] == 0) 
	    || ([string compare [lindex $IDLOperation($operationName) 1] "void"] == 0)} {
	    return "NULL"
	} else {
	    return "answer"
	}
    } else {
	return [appendStr $interfaceName "_" $operationName "Answer"]
    }
}

###############################################################################
#
# Procedure: removeStr
# Returns: returns the new string
# Description: create a new string which contains from less toRemove
#
###############################################################################
proc removeStr {from toRemove} {
    
    set toReturn $from
    set ampPos [string first $toRemove $from]

    if {$ampPos != -1} {
	set toReturn [string range $from 0 [expr $ampPos - 1]]
	append toReturn [string range $from [expr $ampPos + [string length $toRemove]] end]
    } 

    return $toReturn
}

###############################################################################
#
# Procedure: checkInterfaceName
# Returns: 
# Description: Checks that Interface Name ends with "Idl"
#              Throws an error if not conform
#
###############################################################################
proc checkInterfaceName {toCheck fileName scriptName} {

    if {[string compare [string range $toCheck [expr [string length $toCheck] - 3] end] "Idl"] != 0} {
	puts [appendStr $scriptName ": IDL interface $toCheck does not end with 'Idl' in $fileName"]
	exit 1
    }
}

###############################################################################
#
# Procedure: getInterfaceName
# Returns: a string containing a comma/new line separated list of all arguments
#          with the "mode Idltype name" format
# Description: return interface name from IDL interface name (remove "Idl" suffix)
#              Make sure to test if interface name ends with "Idl" first by 
#              calling checkInterfaceName
#
###############################################################################
proc getInterfaceName {toExtract} {
    
    return [string range $toExtract 0 [expr [string length $toExtract] - 4]]
}

###############################################################################
#
# Procedure: getIdlIncludes
# Returns: a string containing a new line separated list of includes for all the
#          types corresponding to an external interface
# Description: See proc getIdlInclude
#
###############################################################################
proc getIdlIncludes {orderedOperationList mode} {

    set toReturn ""

    foreach {operation} $orderedOperationList {
	set operationName [lindex $operation 1]

	append toReturn [operationArgs $operationName cxx $mode 0 0 0 0 getIdlInclude]
    }

    # operationArgs generate a ", " for each argument which is not a pointer.
    # get rid of them.
    set toReturn [replace $toReturn ", " ""]

    return $toReturn
}

###############################################################################
#
# Procedure: getIdlInclude
# Returns: if kind is ptr (corresponding to an instance of another interface)
#          return the include statement for that type
# Description: assumes that for each ptr, a type.idl file exists where type is 
#              the cxxType less "Idl"
#
###############################################################################
proc getIdlInclude {cxxType name kind pos mode operationName cxxOutType idlType} {

    global startIdl

    set toReturn ""

    if {[string compare $kind "ptr"] == 0} {

	# Make sure that type ends with "Idl"
	checkInterfaceName [replace $cxxType "_ptr" "" 1] $startIdl "proxygenutil"

	# get rid of extra "Idl" and reduce to lower case
	set toReturn [appendStr "\#include \"" [string tolower [getInterfaceName [replace $cxxType "_ptr" "" 1]]] ".idl\"\n"]
    }

    return $toReturn
}

